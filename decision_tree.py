# -*- coding: utf-8 -*-
"""DECISION TREE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gaa4k5wwU7qlAJJuwfPTSs7hukHXURN4
"""

!git clone https://github.com/rawrawiz/ICNN.git

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/ICNN

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import random
from collections import Counter

!pip install anytree

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
sns.set_style("darkgrid")

data = pd.read_csv("/content/drive/MyDrive/THESIS/decision_tree.txt")
df = data.to_csv('df.csv', index=False)
df = pd.read_csv('df.csv')
df = df.drop('id',axis=1)
df

len(df)

df=df.astype(object) 
y = np.random.rand(85)
y = np.array(y)
y = np.transpose(y)
y = [np.round(x,5) for x in y]
y_lst = y
df['predictions'] = y_lst

df['weights']=df['weights'].astype(object) 
#df['weights']=np.array([4,4])
#df.iloc[0,'weights'] = np.array([4,4,4])
df ['predictions'] = y_lst
x = np.random.rand(4)
df.at[2,'weights'] = np.array([4,4,4],dtype=object)
df



for i in range(85): 
  x = np.random.rand(3) #no. of feature maps dapat #testing if this will wokrk w a vector in a cell
  df.iloc[i,'weights'] = x

x = np.random.rand(85)
x = np.array(x)
x = np.transpose(x)
x = [np.round(j,2) for j in x]
x_lst = x
g = np.random.rand(85)
g = np.array(g)
g = np.transpose(g)
g = [np.round(j,2) for j in g]
g_lst = g

df = pd.DataFrame(columns=[1])
df[1] = df[1].astype(object)
df.loc[1, 1] = np.array([5, 6, 7, 8])
df

np.random.rand(3)

df['predictionscore'] = y_lst
df['weight'] = x_lst
df['rationale']=g_lst

import numpy as np
import pandas as pd
import math
import itertools
from anytree import Node, RenderTree
from pandas._libs.algos import backfill
#cosine similarity
from numpy import dot
from numpy.linalg import norm

def get_Qxi(df,j): #dataframe of positive images only
  h_lst=[]
  h_xj = df.loc[j, 'predictionscore']
  for i in range(len(df['predictionscore'])):
    h_xi = df.loc[i, 'predictionscore']
    h_lst.append(h_xi)
  h_lst = np.array(h_lst)
  denominator_Qxi = sum(np.exp(gamma*h_lst))
  Q_xi = np.exp(gamma*h_xj)/denominator_Qxi
  return Q_xi

def get_mean_positive(df): #will be used for computation of gamma
  y_i = []
  for i in range(len(df)): 
    if df.loc[i,'true/false']==1:
      y = df.loc[i,'predictionscore']
    else:
      y=0
    y_i.append(y)
  return y_i

def get_denominator_Pxi(df): #df is all training images (true+false)
  h_lst=[]
  for w in range(len(df['node'])):
    h_xi = df.loc[w, 'node']
    h_lst.append(h_xi)
  h_lst = np.array(h_lst)
  denominator_Pxi = sum(np.exp(gamma*h_lst))
  return denominator_Pxi

#should contain both true/false images
def get_Pxi(df,gamma,j): #j is the jth image
  h_xj = df.loc[j, 'node']
  denominator_Pxi=get_denominator_Pxi(df)
  P_xi = np.exp(gamma*h_xj)/denominator_Pxi
  return P_xi

def get_change_logE(df,v1,v2,sparsity):
  E_v1 = np.log((get_Pxi(df,gamma,v1)/Q_xi)*sparsity)
  E_v2 = np.log((get_Pxi(df,gamma,v2)/Q_xi)*sparsity)
  Delta_E = abs(E_v1-E_v2)
  return Delta_E

def get_cosine_similarity(vec_a,vec_b):
  cos_sim = dot(vec_a, vec_b)/(norm(vec_a)*norm(vec_b))
  return cos_sim
def get_b_parameter(y,g,x):
  b = y - np.multiply(g,x)
  return b
def get_w_vec(alpha,g_vec):
  w_vec = np.multiply(alpha,g_vec)
  return w_vec
def get_hv_xi(w,x,b):
  hv_xi = np.dot(np.transpose(w),x)+b
  return hv_xi

root = Node("Root")
def decisiontree_initial(df):
  node_lst = []
  weight_lst = []
  rationale_lst =[]
  for i in range(len(df['predictionscore'])):
    node = df.loc[i,'predictionscore']
    weight = df.loc[i, 'weight']
    rationale = df.loc[i,'rationale']
    node_lst.append(node)
    weight_lst.append(weight)
    rationale_lst.append(rationale)
    f_i = Node(df.loc[i,'predictionscore'],parent=root)
  df_new = pd.DataFrame()
  df_new['index'] = range(0, len(df))
  df_new['node'] = node_lst
  df_new['weight'] = weight_lst
  df_new['rationale'] = rationale_lst
  return df_new

import random

import random

    """node_lst = []
    weight_lst = []
    rationale_lst =[]
    for i in range(len(df['node'])):
      node = df.loc[i,'node']
      weight = df.loc[i, 'weight']
      rationale = df.loc[i,'rationale']
      node_lst.append(node)
      weight_lst.append(weight)
      rationale_lst.append(rationale)
      f_i = Node(df.loc[i,'node'],parent=root)
    df_new = pd.DataFrame()
    df_new['index'] = range(0, len(df))
    df_new['node'] = node_lst
    df_new['weight'] = weight_lst
    df_new['rationale'] = rationale_lst"""



def get_nodes_to_merge(v_nodes_lst,df):
  maxE=-0.01
  for i,j in v_nodes_lst:
    E_i=get_change_logE(df,i,j,sparsity)/2
    if E_i > maxE:
      maxE = E_i
      i_max=i
      j_max=j
    else:
      maxE=0
      i_max=0
      j_max=0
    return i_max,j_max,maxE
  

def grow_tree(df,v_nodes_lst):
    dic={}
    normV = len(root.children)
    beta = 1
    lambda_parameter = 10**(-6)*np.sqrt(1) #sqrt of child of v dapat
    sparsity = np.exp(-beta*normV)
    i_max,j_max,maxE = get_nodes_to_merge(v_nodes_lst,df)
    alpha = [0,1]
    alpha_lst= list(itertools.combinations(alpha, 256))
    hv_xi_new_u = random.uniform(0, 1) #joke onle sample lng xd
    weight_new_u = random.uniform(0, 1) #joke onle sample lng xd
    rationale_new_u = random.uniform(0, 1) #joke onle sample lng xd
    new_row = {'node':hv_xi_new_u, 'weight':weight_new_u, 'rationale':rationale_new_u}
    df1 = df.append(new_row, ignore_index=True)
    u = Node(hv_xi_new_u,parent=root)
    v = Node(df1.loc[i_max,'node'],parent = u)
    v = Node(df1.loc[j_max,'node'],parent = u)
    df1 = df1.drop([df1.index[i_max],df1.index[j_max]])
    df1 = df1.reset_index(drop=True)
    df1['index']=range(0, len(df1))
    v_nodes_lst = list(itertools.combinations(df1['index'], 2))
    return df1, v_nodes_lst, maxE

df1 = decisiontree_initial(df)
y_i=get_mean_positive(df)
gamma = 1/(np.mean(y_i)) #y_i are positive images ONLY
Q_xi_lst = []
for j in range(len(df)):
  Q_xi = get_Qxi(df,j)
  Q_xi_lst.append(Q_xi)
Q_xi = np.prod(Q_xi_lst)
v_nodes_lst = list(itertools.combinations(df1['index'], 2))
maxE=-1
while maxE>0 and len(v_nodes_lst)>2:
  df1,v_nodes_lst,maxE = grow_tree(df1,v_nodes_lst)

  #_,_,maxE = get_nodes_to_merge(v_nodes_lst,df1)

for pre, fill, node in RenderTree(root):
  print("%s%s" % (pre, node.name))

"""
while maxE >=0:
  i, j, maxE = get_nodes_to_merge(v_nodes_lst,df1)
  df1,v_nodes_lst = grow_tree(df1,v_nodes_lst

#df1, v_nodes_lst = grow_tree(df1,v_nodes_lst)
df1.loc[36,'node']

df1.loc[461,'node']

from anytree.exporter import DotExporter
DotExporter(root).to_picture("udo.png")

from anytree import Node
from anytree import find

root = Node("f")
b = Node("b", parent=root)
d = Node("d", parent=b)
c = Node("c", parent=d)

name='c'
result = find(root, lambda node: node.name == name)

print('result Node:', result)

if result.parent:
    print('parent name:', result.parent.name)

if result.parent and result.parent.parent:
    print('grandparent:', result.parent.parent.name)

